# -*- coding: utf-8 -*-
"""RecupMatchs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G7K70fXhKwbOc0-FLdrxbVrAsrpZNxOo

## **Vide les tables**
"""

import requests
import psycopg2
from datetime import datetime, timedelta


# üîë Cl√© API SportsData.io
API_KEY = "f5dfafaf901b41b0898c6277c72300ea"

today = datetime.today().date()
yesterday = today - timedelta(days=1)

# üèÜ Liste des comp√©titions √† r√©cup√©rer
COMPETITIONS = {
    "Premier League": "1",
    "Bundesliga": "2",
    "La Liga": "4",
    "Serie A": "6",
    "Ligue 1": "13",
    "UEFA Champions League": "3",
    "UEFA Europa League": "9",
    "UEFA Europa Conference League": "55",
    "Eredivisie": "7",
    "2. Bundesliga": "74",
    "Saudi Professional League": "50"
}

# üîå Connexion PostgreSQL Railway
DATABASE_URL = "postgresql://postgres:jDDqfaqpspVDBBwsqxuaiSDNXjTxjMmP@shortline.proxy.rlwy.net:36536/railway"
conn = psycopg2.connect(DATABASE_URL)
cursor = conn.cursor()


# üìÜ G√©n√©rer les dates de la saison
#date_debut = datetime(2025, 3, 8)
#date_fin = datetime(2025, 3, 23)
#nb_jours = (date_fin - date_debut).days


print("Fin de la d√©fintion de variables")

"""# **üìå 1Ô∏è‚É£ R√©cup√©ration des Matchs**"""

def recuperer_matchs(date, API_KEY):
  # R√©cup√®re les matchs du jour et les ins√®re dans la table 'matchs'.
  for competition_name, competition_id in COMPETITIONS.items():
      #print(f"üîç R√©cup√©ration des matchs pour {competition_name} ({competition_id})...")

      # üîó URL API pour r√©cup√©rer les matchs
      url = f"https://api.sportsdata.io/v4/soccer/scores/json/GamesByDate/{competition_id}/{date}?key={API_KEY}"
      response = requests.get(url)

      if response.status_code == 200:
          data = response.json()

          if not data:  # V√©rifier si la liste est vide
              #print(f"‚ö†Ô∏è Aucun match trouv√© pour {competition_name} ({competition_id})")
              continue

          for match in data:
              game_id = match["GameId"]
              saison = datetime.strptime(match["DateTime"], "%Y-%m-%dT%H:%M:%S").year
              date_match = match["DateTime"]
              statut = match["Status"]
              equipe_domicile = match["HomeTeamName"]
              equipe_exterieur = match["AwayTeamName"]
              competition = competition_name

              # üèÜ Ins√©rer dans la table matchs
              cursor.execute("""
                  INSERT INTO matchs (game_id, saison, date, statut, equipe_domicile, equipe_exterieur, competition)
                  VALUES (%s, %s, %s, %s, %s, %s, %s)
                  ON CONFLICT (game_id) DO NOTHING
              """, (game_id, saison, date_match, statut, equipe_domicile, equipe_exterieur, competition))

      else:
          print(f"‚ùå Erreur API pour {competition_name} ({competition_id}) : {response.status_code}")

  # ‚úÖ Confirmer l'insertion
  conn.commit()
  print("‚úÖ Donn√©es des matchs ins√©r√©es avec succ√®s !")

"""# **üìå 2Ô∏è‚É£ R√©cup√©ration des Statistiques des Matchs**"""

# Fonction de conversion s√©curis√©e
import math

def convert_to_int(value):
    """Convertit une valeur en int, arrondie √† l'entier inf√©rieur sauf si cela tombe en dessous de 0."""
    try:
        x = float(value)
        return max(math.floor(x), 0)  # Arrondi en bas, mais pas en dessous de 0
    except (ValueError, TypeError):
        return 0  # Retourne 0 si la donn√©e est invalide

def recuperer_stats_matchs(date, API_KEY):
  # R√©cup√®re les statistiques des matchs et les ins√®re dans la table 'stats_matchs'.
  for competition_name, competition_id in COMPETITIONS.items():
      #print(f"üîç R√©cup√©ration des statistiques pour {competition_name} ({competition_id})...")

      # üîó URL API pour r√©cup√©rer les stats des matchs
      url = f"https://api.sportsdata.io/v4/soccer/stats/json/TeamGameStatsByDateFinal/{competition_id}/{date}?key={API_KEY}"
      response = requests.get(url)

      if response.status_code == 200:
          data = response.json()

          if not data:
              #print(f"‚ö†Ô∏è Aucune statistique trouv√©e pour {competition_name} ({competition_id})")
              continue

          match_stats = {}
          for stats in data:
              game_id = stats["GameId"]
              team_id = stats["TeamId"]

              if game_id not in match_stats:
                  match_stats[game_id] = {}
              match_stats[game_id][team_id] = stats

          for game_id, teams in match_stats.items():
              if len(teams) == 2:
                  team_ids = list(teams.keys())
                  stats_dom = teams[team_ids[0]]
                  stats_ext = teams[team_ids[1]]

                  # Cr√©ation des valeurs avec conversion en int
                  values = (
                      convert_to_int(game_id),
                      convert_to_int(stats_dom.get("Possession")), convert_to_int(stats_ext.get("Possession")),
                      convert_to_int(stats_dom.get("Shots")), convert_to_int(stats_ext.get("Shots")),
                      convert_to_int(stats_dom.get("ShotsOnGoal")), convert_to_int(stats_ext.get("ShotsOnGoal")),
                      convert_to_int(stats_dom.get("Goals")), convert_to_int(stats_ext.get("Goals")),
                      convert_to_int(stats_dom.get("Passes")), convert_to_int(stats_ext.get("Passes")),
                      convert_to_int(stats_dom.get("PassesCompleted")), convert_to_int(stats_ext.get("PassesCompleted")),
                      convert_to_int(stats_dom.get("CornersWon")), convert_to_int(stats_ext.get("CornersWon")),
                      convert_to_int(stats_dom.get("Fouls")), convert_to_int(stats_ext.get("Fouls")),
                      convert_to_int(stats_dom.get("Offsides")), convert_to_int(stats_ext.get("Offsides")),
                      convert_to_int(stats_dom.get("YellowCards")), convert_to_int(stats_ext.get("YellowCards")),
                      convert_to_int(stats_dom.get("RedCards")), convert_to_int(stats_ext.get("RedCards")),
                      convert_to_int(stats_dom.get("Interceptions")), convert_to_int(stats_ext.get("Interceptions")),
                      convert_to_int(stats_dom.get("Tackles")), convert_to_int(stats_ext.get("Tackles"))
                  )

                  # Debugging: Affichage des valeurs AVANT insertion
                  #print(f"üìù Tentative d'insertion pour game_id {game_id}")
                  #print(f"üì• Values: {values}")
                  #print(f"üì• Values ins√©r√©es: {values}")
                  #for i, v in enumerate(values):
                      #print(f"Index {i}: {v} (Type: {type(v)})")


                  # Requ√™te SQL
                  query = """
                      INSERT INTO stats_matchs (
                                  game_id, possession_dom, possession_ext,
                                  tirs_dom, tirs_ext, tirs_cadres_dom, tirs_cadres_ext, buts_dom, buts_ext,
                                  passes_dom, passes_ext, passes_reussies_dom, passes_reussies_ext,
                                  corners_dom, corners_ext, fautes_dom, fautes_ext,
                                  hors_jeu_dom, hors_jeu_ext, cartons_jaunes_dom, cartons_jaunes_ext,
                                  cartons_rouges_dom, cartons_rouges_ext, interceptions_dom, interceptions_ext,
                                  tacles_dom, tacles_ext
                              ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                              ON CONFLICT (game_id) DO NOTHING
                  """

                  try:
                      cursor.execute(query, values)
                  except Exception as e:
                      print(f"‚ùå Erreur lors de l'insertion des donn√©es pour game_id {game_id}: {e}")

  # ‚úÖ Confirmer l'insertion
  conn.commit()
  print("‚úÖ Donn√©es des statistiques ins√©r√©es avec succ√®s !")

"""# **üìå 3Ô∏è‚É£ R√©cup√©ration des Cotes**"""

def recuperer_cotes(date, API_KEY):
    for competition_name, competition_id in COMPETITIONS.items():
        url = f"https://api.sportsdata.io/v4/soccer/odds/json/GameOddsByDate/{competition_id}/{date}?key={API_KEY}"
        response = requests.get(url)

        if response.status_code == 200:
            data = response.json()

            for match in data:
                game_id = match["GameId"]

                cursor.execute("SELECT game_id FROM matchs WHERE game_id = %s", (game_id,))
                match_row = cursor.fetchone()

                if match_row:
                    id_match = match_row[0]

                    cursor.execute("SELECT COUNT(*) FROM cotes WHERE game_id = %s", (game_id,))
                    cote_existante = cursor.fetchone()[0]

                    if cote_existante == 0:
                        for odd in match.get("PregameOdds", [])[:1]:

                            cote_domicile = 1 + (odd["HomeMoneyLine"] / 100) if odd["HomeMoneyLine"] and odd["HomeMoneyLine"] > 0 else 1 + (100 / abs(odd["HomeMoneyLine"])) if odd["HomeMoneyLine"] else None
                            cote_nul = 1 + (odd["DrawMoneyLine"] / 100) if odd["DrawMoneyLine"] and odd["DrawMoneyLine"] > 0 else 1 + (100 / abs(odd["DrawMoneyLine"])) if odd["DrawMoneyLine"] else None
                            cote_exterieur = 1 + (odd["AwayMoneyLine"] / 100) if odd["AwayMoneyLine"] and odd["AwayMoneyLine"] > 0 else 1 + (100 / abs(odd["AwayMoneyLine"])) if odd["AwayMoneyLine"] else None

                            cote_double_chance_1N = 1 / ((1 / cote_domicile) + (1 / cote_nul)) if cote_domicile and cote_nul else None
                            cote_double_chance_12 = 1 / ((1 / cote_domicile) + (1 / cote_exterieur)) if cote_domicile and cote_exterieur else None
                            cote_double_chance_X2 = 1 / ((1 / cote_exterieur) + (1 / cote_nul)) if cote_exterieur and cote_nul else None

                            over_under_ligne = odd.get("OverUnder")

                            cote_over = None
                            cote_under = None

                            if odd.get("OverPayout") is not None and odd["OverPayout"] != 0:
                                cote_over = 1 + (odd["OverPayout"] / 100) if odd["OverPayout"] > 0 else 1 + (100 / abs(odd["OverPayout"]))
                            else:
                                cote_over = None  # Ou d√©finir une valeur par d√©faut

                            if odd.get("UnderPayout") is not None and odd["UnderPayout"] != 0:
                                cote_under = 1 + (odd["UnderPayout"] / 100) if odd["UnderPayout"] > 0 else 1 + (100 / abs(odd["UnderPayout"]))
                            else:
                                cote_under = None  # Ou d√©finir une valeur par d√©faut


                            cursor.execute("""
                                INSERT INTO cotes (game_id, cote_domicile, cote_nul, cote_exterieur,
                                                  cote_double_chance_1N, cote_double_chance_12, cote_double_chance_X2,
                                                  over_under_ligne, cote_over, cote_under)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                                ON CONFLICT (game_id) DO NOTHING
                            """, (game_id, cote_domicile, cote_nul, cote_exterieur,
                                  cote_double_chance_1N, cote_double_chance_12, cote_double_chance_X2,
                                  over_under_ligne, cote_over, cote_under))

                            conn.commit()

                    else:
                        print(f"‚ö†Ô∏è Cotes d√©j√† existantes pour le match {game_id} ({competition_name}). Aucune insertion.")

                else:
                    print(f"‚ö†Ô∏è Match {game_id} non trouv√© dans la table matchs. Impossible d'ins√©rer les cotes.")

        else:
            print(f"‚ùå Erreur API SportsData.io ({competition_name}) : {response.status_code}")

    print("‚úÖ Int√©gration compl√®te des cotes depuis SportsData.io termin√©e pour toutes les comp√©titions !")

def mettre_a_jour_stats_globales(date_reference):
    print("üìä Mise √† jour des stats globales des √©quipes ayant jou√© le", date_reference)

    # R√©cup√®re les √©quipes concern√©es par des matchs hier
    cursor.execute("""
        SELECT DISTINCT m.saison, m.competition, m.equipe_domicile AS equipe
        FROM matchs m
        JOIN stats_matchs s ON m.game_id = s.game_id
        WHERE m.date::date = %s
        UNION
        SELECT DISTINCT m.saison, m.competition, m.equipe_exterieur AS equipe
        FROM matchs m
        JOIN stats_matchs s ON m.game_id = s.game_id
        WHERE m.date::date = %s
    """, (date_reference, date_reference))
    equipes = cursor.fetchall()

    for saison, competition, equipe in equipes:
        cursor.execute("""
            SELECT m.game_id, m.equipe_domicile, m.equipe_exterieur,
                   s.buts_dom, s.buts_ext, s.tirs_dom, s.tirs_ext, s.tirs_cadres_dom, s.tirs_cadres_ext,
                   s.possession_dom, s.possession_ext, s.passes_reussies_dom, s.passes_reussies_ext,
                   s.corners_dom, s.corners_ext, s.cartons_jaunes_dom, s.cartons_jaunes_ext,
                   s.cartons_rouges_dom, s.cartons_rouges_ext, s.interceptions_dom, s.interceptions_ext,
                   s.tacles_dom, s.tacles_ext, s.fautes_dom, s.fautes_ext, s.hors_jeu_dom, s.hors_jeu_ext
            FROM matchs m
            JOIN stats_matchs s ON m.game_id = s.game_id
            WHERE m.saison = %s AND m.competition = %s
              AND (m.equipe_domicile = %s OR m.equipe_exterieur = %s)
        """, (saison, competition, equipe, equipe))
        matchs = cursor.fetchall()

        if not matchs:
            continue

        total = {
            "matchs_joues": 0, "victoires": 0, "nuls": 0, "defaites": 0,
            "buts_marques": 0, "buts_encaisse": 0, "difference_buts": 0,
            "tirs": 0, "tirs_cadres": 0, "possession": 0, "passes_reussies": 0,
            "corners": 0, "cartons_jaunes": 0, "cartons_rouges": 0,
            "interceptions": 0, "tacles": 0, "fautes": 0, "hors_jeu": 0,
            "btts": 0, "over_2_5": 0, "over_1_5": 0, "clean_sheets": 0
        }

        for match in matchs:
            (
                game_id, dom, ext, bdom, bext, tirs_dom, tirs_ext, tirs_cadres_dom, tirs_cadres_ext,
                pos_dom, pos_ext, pass_dom, pass_ext,
                corners_dom, corners_ext, jaunes_dom, jaunes_ext,
                rouges_dom, rouges_ext, inter_dom, inter_ext,
                tacles_dom, tacles_ext, fautes_dom, fautes_ext, hj_dom, hj_ext
            ) = match

            est_domicile = (equipe == dom)

            buts_marques = bdom if est_domicile else bext
            buts_encaisse = bext if est_domicile else bdom

            total["matchs_joues"] += 1
            total["buts_marques"] += buts_marques
            total["buts_encaisse"] += buts_encaisse
            total["difference_buts"] += (buts_marques - buts_encaisse)

            total["victoires"] += int(buts_marques > buts_encaisse)
            total["nuls"] += int(buts_marques == buts_encaisse)
            total["defaites"] += int(buts_marques < buts_encaisse)

            total["tirs"] += tirs_dom if est_domicile else tirs_ext
            total["tirs_cadres"] += tirs_cadres_dom if est_domicile else tirs_cadres_ext
            total["possession"] += pos_dom if est_domicile else pos_ext
            total["passes_reussies"] += pass_dom if est_domicile else pass_ext
            total["corners"] += corners_dom if est_domicile else corners_ext
            total["cartons_jaunes"] += jaunes_dom if est_domicile else jaunes_ext
            total["cartons_rouges"] += rouges_dom if est_domicile else rouges_ext
            total["interceptions"] += inter_dom if est_domicile else inter_ext
            total["tacles"] += tacles_dom if est_domicile else tacles_ext
            total["fautes"] += fautes_dom if est_domicile else fautes_ext
            total["hors_jeu"] += hj_dom if est_domicile else hj_ext

            if bdom > 0 and bext > 0:
                total["btts"] += 1
            if (bdom + bext) > 2.5:
                total["over_2_5"] += 1
            if (bdom + bext) > 1.5:
                total["over_1_5"] += 1
            if buts_encaisse == 0:
                total["clean_sheets"] += 1

        def avg(val):
            return round(val / total["matchs_joues"], 2)

        insert_values = (
            equipe, competition, saison,
            total["matchs_joues"], total["victoires"], total["nuls"], total["defaites"],
            total["buts_marques"], total["buts_encaisse"], total["difference_buts"],
            total["tirs"], total["tirs_cadres"], avg(total["possession"]),
            avg(total["passes_reussies"]), total["corners"], total["cartons_jaunes"],
            total["cartons_rouges"], total["interceptions"], total["tacles"],
            total["fautes"], total["hors_jeu"],
            avg(total["buts_marques"]),
            round(100 * total["btts"] / total["matchs_joues"], 2),
            round(100 * total["over_2_5"] / total["matchs_joues"], 2),
            round(100 * total["over_1_5"] / total["matchs_joues"], 2),
            round(100 * total["clean_sheets"] / total["matchs_joues"], 2)
        )

        cursor.execute("""
            INSERT INTO stats_globales (
                equipe, competition, saison, matchs_joues, victoires, nuls, defaites,
                buts_marques, buts_encaisse, difference_buts, tirs, tirs_cadres, possession,
                passes_reussies, corners, cartons_jaunes, cartons_rouges, interceptions,
                tacles, fautes, hors_jeu, moyenne_buts, pourcentage_BTTS, pourcentage_over_2_5,
                pourcentage_over_1_5, pourcentage_clean_sheets
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (equipe, competition, saison)
            DO UPDATE SET
                matchs_joues = EXCLUDED.matchs_joues,
                victoires = EXCLUDED.victoires,
                nuls = EXCLUDED.nuls,
                defaites = EXCLUDED.defaites,
                buts_marques = EXCLUDED.buts_marques,
                buts_encaisse = EXCLUDED.buts_encaisse,
                difference_buts = EXCLUDED.difference_buts,
                tirs = EXCLUDED.tirs,
                tirs_cadres = EXCLUDED.tirs_cadres,
                possession = EXCLUDED.possession,
                passes_reussies = EXCLUDED.passes_reussies,
                corners = EXCLUDED.corners,
                cartons_jaunes = EXCLUDED.cartons_jaunes,
                cartons_rouges = EXCLUDED.cartons_rouges,
                interceptions = EXCLUDED.interceptions,
                tacles = EXCLUDED.tacles,
                fautes = EXCLUDED.fautes,
                hors_jeu = EXCLUDED.hors_jeu,
                moyenne_buts = EXCLUDED.moyenne_buts,
                pourcentage_BTTS = EXCLUDED.pourcentage_BTTS,
                pourcentage_over_2_5 = EXCLUDED.pourcentage_over_2_5,
                pourcentage_over_1_5 = EXCLUDED.pourcentage_over_1_5,
                pourcentage_clean_sheets = EXCLUDED.pourcentage_clean_sheets
        """, insert_values)

    conn.commit()
    print("‚úÖ stats_globales mise √† jour avec succ√®s !")


recuperer_matchs(today, API_KEY)
recuperer_stats_matchs(yesterday, API_KEY)
recuperer_cotes(today, API_KEY)
mettre_a_jour_stats_globales(yesterday)

conn.commit()

print("‚úÖ R√©cup√©ration des donn√©es termin√©e !")

"""## **Envoie de mail et execution des fonction de r√©cup√©ration de donn√©es**"""

import smtplib
from email.mime.text import MIMEText

def send_email(subject, body, to_email):
    from_email = "lilian.pamphile.bts@gmail.com"
    password = "fifkktsenfxsqiob"  # mot de passe d'application

    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = from_email
    msg["To"] = to_email

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(from_email, password)
            server.send_message(msg)
        print("üì¨ Email envoy√© avec succ√®s.")
    except Exception as e:
        print("‚ùå Erreur lors de l'envoi de l'email :", e)

################################################################

try:
    recuperer_matchs(today, API_KEY)
    recuperer_stats_matchs(yesterday, API_KEY)
    recuperer_cotes(today, API_KEY)

    conn.commit()

    print("‚úÖ R√©cup√©ration des donn√©es termin√©e !")

    send_email(
        subject="‚úÖ Succ√®s - Script de r√©cup√©ration des matchs",
        body=f"Le script s'est ex√©cut√© avec succ√®s le {today}.",
        to_email="lilian.pamphile.bts@gmail.com"
    )

except Exception as e:
    # Si une erreur survient √† n‚Äôimporte quelle cellule
    error_message = f"‚ùå Erreur durant l‚Äôex√©cution du script Match_historique du {today} :\n\n{str(e)}"
    send_email(
        subject="‚ùå √âchec - Script Match_historique",
        body=error_message,
        to_email="lilian.pamphile.bts@gmail.com"
    )
