# -*- coding: utf-8 -*-
"""RecupMatchs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G7K70fXhKwbOc0-FLdrxbVrAsrpZNxOo

## **Vide les tables**
"""

import requests
import psycopg2
from datetime import datetime, timedelta


# üîë Cl√© API SportsData.io
API_KEY = "f5dfafaf901b41b0898c6277c72300ea"

today = datetime.today().date()
yesterday = today - timedelta(days=1)

# üèÜ Liste des comp√©titions √† r√©cup√©rer
COMPETITIONS = {
    "Premier League": "1",
    "Bundesliga": "2",
    "La Liga": "4",
    "Serie A": "6",
    "Ligue 1": "13",
    "UEFA Champions League": "3",
    "UEFA Europa League": "9",
    "UEFA Europa Conference League": "55",
    "Eredivisie": "7",
    "2. Bundesliga": "74",
    "Saudi Professional League": "50"
}

# üîå Connexion PostgreSQL Railway
DATABASE_URL = "postgresql://postgres:jDDqfaqpspVDBBwsqxuaiSDNXjTxjMmP@shortline.proxy.rlwy.net:36536/railway"
conn = psycopg2.connect(DATABASE_URL)
cursor = conn.cursor()


# üìÜ G√©n√©rer les dates de la saison
#date_debut = datetime(2025, 3, 8)
#date_fin = datetime(2025, 3, 23)
#nb_jours = (date_fin - date_debut).days


print("Fin de la d√©fintion de variables")

"""# **üìå 1Ô∏è‚É£ R√©cup√©ration des Matchs**"""

def recuperer_matchs(date, API_KEY):
  # R√©cup√®re les matchs du jour et les ins√®re dans la table 'matchs'.
  for competition_name, competition_id in COMPETITIONS.items():
      #print(f"üîç R√©cup√©ration des matchs pour {competition_name} ({competition_id})...")

      # üîó URL API pour r√©cup√©rer les matchs
      url = f"https://api.sportsdata.io/v4/soccer/scores/json/GamesByDate/{competition_id}/{DATE}?key={API_KEY}"
      response = requests.get(url)

      if response.status_code == 200:
          data = response.json()

          if not data:  # V√©rifier si la liste est vide
              #print(f"‚ö†Ô∏è Aucun match trouv√© pour {competition_name} ({competition_id})")
              continue

          for match in data:
              game_id = match["GameId"]
              saison = datetime.strptime(match["DateTime"], "%Y-%m-%dT%H:%M:%S").year
              date_match = match["DateTime"]
              statut = match["Status"]
              equipe_domicile = match["HomeTeamName"]
              equipe_exterieur = match["AwayTeamName"]
              competition = competition_name

              # üèÜ Ins√©rer dans la table matchs
              cursor.execute("""
                  INSERT INTO matchs (game_id, saison, date, statut, equipe_domicile, equipe_exterieur, competition)
                  VALUES (%s, %s, %s, %s, %s, %s, %s)
                  ON CONFLICT (game_id) DO NOTHING
              """, (game_id, saison, date_match, statut, equipe_domicile, equipe_exterieur, competition))

      else:
          print(f"‚ùå Erreur API pour {competition_name} ({competition_id}) : {response.status_code}")

  # ‚úÖ Confirmer l'insertion
  conn.commit()
  print("‚úÖ Donn√©es des matchs ins√©r√©es avec succ√®s !")

"""# **üìå 2Ô∏è‚É£ R√©cup√©ration des Statistiques des Matchs**"""

# Fonction de conversion s√©curis√©e
import math

def convert_to_int(value):
    """Convertit une valeur en int, arrondie √† l'entier inf√©rieur sauf si cela tombe en dessous de 0."""
    try:
        x = float(value)
        return max(math.floor(x), 0)  # Arrondi en bas, mais pas en dessous de 0
    except (ValueError, TypeError):
        return 0  # Retourne 0 si la donn√©e est invalide

def recuperer_stats_matchs(date, API_KEY):
  # R√©cup√®re les statistiques des matchs et les ins√®re dans la table 'stats_matchs'.
  for competition_name, competition_id in COMPETITIONS.items():
      #print(f"üîç R√©cup√©ration des statistiques pour {competition_name} ({competition_id})...")

      # üîó URL API pour r√©cup√©rer les stats des matchs
      url = f"https://api.sportsdata.io/v4/soccer/stats/json/TeamGameStatsByDateFinal/{competition_id}/{DATE}?key={API_KEY}"
      response = requests.get(url)

      if response.status_code == 200:
          data = response.json()

          if not data:
              #print(f"‚ö†Ô∏è Aucune statistique trouv√©e pour {competition_name} ({competition_id})")
              continue

          match_stats = {}
          for stats in data:
              game_id = stats["GameId"]
              team_id = stats["TeamId"]

              if game_id not in match_stats:
                  match_stats[game_id] = {}
              match_stats[game_id][team_id] = stats

          for game_id, teams in match_stats.items():
              if len(teams) == 2:
                  team_ids = list(teams.keys())
                  stats_dom = teams[team_ids[0]]
                  stats_ext = teams[team_ids[1]]

                  # Cr√©ation des valeurs avec conversion en int
                  values = (
                      convert_to_int(game_id),
                      convert_to_int(stats_dom.get("Possession")), convert_to_int(stats_ext.get("Possession")),
                      convert_to_int(stats_dom.get("Shots")), convert_to_int(stats_ext.get("Shots")),
                      convert_to_int(stats_dom.get("ShotsOnGoal")), convert_to_int(stats_ext.get("ShotsOnGoal")),
                      convert_to_int(stats_dom.get("Goals")), convert_to_int(stats_ext.get("Goals")),
                      convert_to_int(stats_dom.get("Passes")), convert_to_int(stats_ext.get("Passes")),
                      convert_to_int(stats_dom.get("PassesCompleted")), convert_to_int(stats_ext.get("PassesCompleted")),
                      convert_to_int(stats_dom.get("CornersWon")), convert_to_int(stats_ext.get("CornersWon")),
                      convert_to_int(stats_dom.get("Fouls")), convert_to_int(stats_ext.get("Fouls")),
                      convert_to_int(stats_dom.get("Offsides")), convert_to_int(stats_ext.get("Offsides")),
                      convert_to_int(stats_dom.get("YellowCards")), convert_to_int(stats_ext.get("YellowCards")),
                      convert_to_int(stats_dom.get("RedCards")), convert_to_int(stats_ext.get("RedCards")),
                      convert_to_int(stats_dom.get("Interceptions")), convert_to_int(stats_ext.get("Interceptions")),
                      convert_to_int(stats_dom.get("Tackles")), convert_to_int(stats_ext.get("Tackles"))
                  )

                  # Debugging: Affichage des valeurs AVANT insertion
                  #print(f"üìù Tentative d'insertion pour game_id {game_id}")
                  #print(f"üì• Values: {values}")
                  #print(f"üì• Values ins√©r√©es: {values}")
                  #for i, v in enumerate(values):
                      #print(f"Index {i}: {v} (Type: {type(v)})")


                  # Requ√™te SQL
                  query = """
                      INSERT INTO stats_matchs (
                                  game_id, possession_dom, possession_ext,
                                  tirs_dom, tirs_ext, tirs_cadres_dom, tirs_cadres_ext, buts_dom, buts_ext,
                                  passes_dom, passes_ext, passes_reussies_dom, passes_reussies_ext,
                                  corners_dom, corners_ext, fautes_dom, fautes_ext,
                                  hors_jeu_dom, hors_jeu_ext, cartons_jaunes_dom, cartons_jaunes_ext,
                                  cartons_rouges_dom, cartons_rouges_ext, interceptions_dom, interceptions_ext,
                                  tacles_dom, tacles_ext
                              ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                              ON CONFLICT (game_id) DO NOTHING
                  """

                  try:
                      cursor.execute(query, values)
                  except Exception as e:
                      print(f"‚ùå Erreur lors de l'insertion des donn√©es pour game_id {game_id}: {e}")

  # ‚úÖ Confirmer l'insertion
  conn.commit()
  print("‚úÖ Donn√©es des statistiques ins√©r√©es avec succ√®s !")

"""# **üìå 3Ô∏è‚É£ R√©cup√©ration des Cotes**"""

def recuperer_cotes(date, API_KEY):
    for competition_name, competition_id in COMPETITIONS.items():
        url = f"https://api.sportsdata.io/v4/soccer/odds/json/GameOddsByDate/{competition_id}/{DATE}?key={API_KEY}"
        response = requests.get(url)

        if response.status_code == 200:
            data = response.json()

            for match in data:
                game_id = match["GameId"]

                cursor.execute("SELECT game_id FROM matchs WHERE game_id = %s", (game_id,))
                match_row = cursor.fetchone()

                if match_row:
                    id_match = match_row[0]

                    cursor.execute("SELECT COUNT(*) FROM cotes WHERE game_id = %s", (game_id,))
                    cote_existante = cursor.fetchone()[0]

                    if cote_existante == 0:
                        for odd in match.get("PregameOdds", [])[:1]:

                            cote_domicile = 1 + (odd["HomeMoneyLine"] / 100) if odd["HomeMoneyLine"] and odd["HomeMoneyLine"] > 0 else 1 + (100 / abs(odd["HomeMoneyLine"])) if odd["HomeMoneyLine"] else None
                            cote_nul = 1 + (odd["DrawMoneyLine"] / 100) if odd["DrawMoneyLine"] and odd["DrawMoneyLine"] > 0 else 1 + (100 / abs(odd["DrawMoneyLine"])) if odd["DrawMoneyLine"] else None
                            cote_exterieur = 1 + (odd["AwayMoneyLine"] / 100) if odd["AwayMoneyLine"] and odd["AwayMoneyLine"] > 0 else 1 + (100 / abs(odd["AwayMoneyLine"])) if odd["AwayMoneyLine"] else None

                            cote_double_chance_1N = 1 / ((1 / cote_domicile) + (1 / cote_nul)) if cote_domicile and cote_nul else None
                            cote_double_chance_12 = 1 / ((1 / cote_domicile) + (1 / cote_exterieur)) if cote_domicile and cote_exterieur else None
                            cote_double_chance_X2 = 1 / ((1 / cote_exterieur) + (1 / cote_nul)) if cote_exterieur and cote_nul else None

                            over_under_ligne = odd.get("OverUnder")

                            cote_over = None
                            cote_under = None

                            if odd.get("OverPayout") is not None and odd["OverPayout"] != 0:
                                cote_over = 1 + (odd["OverPayout"] / 100) if odd["OverPayout"] > 0 else 1 + (100 / abs(odd["OverPayout"]))
                            else:
                                cote_over = None  # Ou d√©finir une valeur par d√©faut

                            if odd.get("UnderPayout") is not None and odd["UnderPayout"] != 0:
                                cote_under = 1 + (odd["UnderPayout"] / 100) if odd["UnderPayout"] > 0 else 1 + (100 / abs(odd["UnderPayout"]))
                            else:
                                cote_under = None  # Ou d√©finir une valeur par d√©faut


                            cursor.execute("""
                                INSERT INTO cotes (game_id, cote_domicile, cote_nul, cote_exterieur,
                                                  cote_double_chance_1N, cote_double_chance_12, cote_double_chance_X2,
                                                  over_under_ligne, cote_over, cote_under)
                                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                                ON CONFLICT (game_id) DO NOTHING
                            """, (game_id, cote_domicile, cote_nul, cote_exterieur,
                                  cote_double_chance_1N, cote_double_chance_12, cote_double_chance_X2,
                                  over_under_ligne, cote_over, cote_under))

                            conn.commit()

                    else:
                        print(f"‚ö†Ô∏è Cotes d√©j√† existantes pour le match {game_id} ({competition_name}). Aucune insertion.")

                else:
                    print(f"‚ö†Ô∏è Match {game_id} non trouv√© dans la table matchs. Impossible d'ins√©rer les cotes.")

        else:
            print(f"‚ùå Erreur API SportsData.io ({competition_name}) : {response.status_code}")

    print("‚úÖ Int√©gration compl√®te des cotes depuis SportsData.io termin√©e pour toutes les comp√©titions !")

recuperer_matchs(today, API_KEY)
recuperer_stats_matchs(yesterday, API_KEY)
recuperer_cotes(today, API_KEY)

conn.commit()

print("‚úÖ R√©cup√©ration des donn√©es termin√©e !")

"""## **Envoie de mail et execution des fonction de r√©cup√©ration de donn√©es**"""

import smtplib
from email.mime.text import MIMEText

def send_email(subject, body, to_email):
    from_email = "lilian.pamphile.bts@gmail.com"
    password = "fifkktsenfxsqiob"  # mot de passe d'application

    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = from_email
    msg["To"] = to_email

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(from_email, password)
            server.send_message(msg)
        print("üì¨ Email envoy√© avec succ√®s.")
    except Exception as e:
        print("‚ùå Erreur lors de l'envoi de l'email :", e)

################################################################

try:
    recuperer_matchs(today, API_KEY)
    recuperer_stats_matchs(yesterday, API_KEY)
    recuperer_cotes(today, API_KEY)

    conn.commit()

    print("‚úÖ R√©cup√©ration des donn√©es termin√©e !")

    send_email(
        subject="‚úÖ Succ√®s - Script de r√©cup√©ration des matchs",
        body=f"Le script s'est ex√©cut√© avec succ√®s le {today}.",
        to_email="lilian.pamphile.bts@gmail.com"
    )

except Exception as e:
    # Si une erreur survient √† n‚Äôimporte quelle cellule
    error_message = f"‚ùå Erreur durant l‚Äôex√©cution du script Match_historique du {today} :\n\n{str(e)}"
    send_email(
        subject="‚ùå √âchec - Script Match_historique",
        body=error_message,
        to_email="lilian.pamphile.bts@gmail.com"
    )